// Copyright (C) 2024 Cade Weinberg
//
// This file is part of inf.
//
// inf is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// inf is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with inf.  If not, see <http://www.gnu.org/licenses/>.

#include <boost/assert.hpp>

#include "core/lexer.hpp"

namespace yy {
void Lexer::up() {
    char const *p = token;
    while (p <= cursor) {
        switch (*p) {
        case '\n':
            location_.lines();
            location_.end.column = 1;
            break;
        case '\t':
        case '\r':
        case ' ':
        default:   location_.columns(); break;
        }
        ++p;
    }
}

Lexer::Token Lexer::advance() {
    while (true) {
        location_.step();
        token = cursor;
        /*!re2c
            re2c:eof           = 0;
            re2c:yyfill:enable = 0;
            re2c:api           = generic;
            re2c:api:style     = free-form;
            re2c:encoding:utf8 = 1;
            re2c:YYCTYPE       = char;
            re2c:YYPEEK        = "*cursor";
            re2c:YYSKIP        = "++cursor;";
            re2c:YYBACKUP      = "marker = cursor;";
            re2c:YYRESTORE     = "cursor = marker;";
            re2c:YYLESSTHAN    = "limit - cursor < @@{len}";

            integer = [0-9]+;
            label = [_a-zA-Z][_a-zA-Z0-9]*;

            * { return Token::Error{
                    context->error(std::string{"unknown character: "} +
           *cursor)}; } $ { return Token::End{}; }

            [\n\t\f\v ] { up(); continue; }

            integer {
                up();
                return inf::Integer{std::string_view{token, cursor}};
            }

            "(" { up(); return Token::LParen{}; }
            ")" { up(); return Token::RParen{}; }
            ";" { up(); return Token::Semicolon{}; }
            "+" { up(); return Token::Plus{}; }
            "-" { up(); return Token::Minus{}; }
            "*" { up(); return Token::Star{}; }
            "/" { up(); return Token::FSlash{}; }
            "%" { up(); return Token::Percent{}; }
        */
    }
}

namespace detail {
struct TokenEqualityVisitor {
    Lexer::Token const *b;

    bool operator()(Lexer::Token::End const &) {
        return b->is<Lexer::Token::End>();
    }

    bool operator()(Lexer::Token::Error const &) { return false; }

    bool operator()(Lexer::Token::Semicolon const &) {
        return b->is<Lexer::Token::Semicolon>();
    }

    bool operator()(Lexer::Token::LParen const &) {
        return b->is<Lexer::Token::LParen>();
    }

    bool operator()(Lexer::Token::RParen const &) {
        return b->is<Lexer::Token::RParen>();
    }

    bool operator()(Lexer::Token::Plus const &) {
        return b->is<Lexer::Token::Plus>();
    }

    bool operator()(Lexer::Token::Minus const &) {
        return b->is<Lexer::Token::Minus>();
    }

    bool operator()(Lexer::Token::Star const &) {
        return b->is<Lexer::Token::Star>();
    }

    bool operator()(Lexer::Token::FSlash const &) {
        return b->is<Lexer::Token::FSlash>();
    }

    bool operator()(Lexer::Token::Percent const &) {
        return b->is<Lexer::Token::Percent>();
    }

    bool operator()(inf::Integer const &i) {
        if (!b->is<inf::Integer>()) { return false; }
        return i == b->as<inf::Integer>();
    }
};
} // namespace detail

bool operator==(Lexer::Token const &a, Lexer::Token const &b) {
    detail::TokenEqualityVisitor visitor{&b};
    return std::visit(visitor, a.get());
}

} // namespace yy
